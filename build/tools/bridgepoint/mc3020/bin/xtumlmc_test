#!perl -w
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
# (C) Copyright Mentor Graphics Corporation  (2004-2005)               #
# All rights reserved.                                                 #
#______________________________________________________________________#

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
# For help by user...
my $help_info = <<'##done##';
# Title:               Test Runner                                      #
# File Name:           xtumlmc_test.pl                                  #
#                                                                       #
# Protocol -                                                            #
#   $ xtumlmc_test.pl -s spec -v varname                                #
#                                                                       #
#     Required command line parameters                                  #
#     --------------------------------                                  #
#     -s = file with the variations                                     #
#     -v = variation to run.  Specify -v all to run all variations.     #
#                                                                       #
#     Optional command line parameters                                  #
#     --------------------------------                                  #
#     -h or -l = help, show program usage                               #
#     -e = execute the resulting executables                            #
#     -g = global set to use.  Specify -g all to run all global sets.   #
#          If this is not specified, the default global set is used.    #
#     -m = model compiler to use.  Specify -m all to run on mc3020 and  #
#          mc2020.  IF this is not specified, mc3020 is used.           #
#     -nw = don't wait for the execution logs to finish before exiting  #
#           If this is not specified, xtumlmc_test will wait.           #
#     -pd = directory to run the unit tests from.  If this is not       #
#           specified, the current directory is used.                   #
#                                                                       #
#                                                                       #
# Examples -                                                            #
#   $ xtumlmc_test.pl -s variations.xml -v pei                          #
#     -runs the pei variation using the default global set              #
#   $ xtumlmc_test.pl -m mc2020 -s variations.xml -v pei                #
#     -runs the pei variation using the default global set and using    #
#      mc2020 for code generation                                       #
#   $ xtumlmc_test.pl -s variations.xml -v pei -g ndnpntns              #
#     -runs the pei variation using mc3020, with the global set ndnpntns#
#      (no debug, no persistence, no tasking, no serialization)         #
#                                                                       #
# Abstract -                                                            #
#   This file run tests.                                                #
#
# -- End information for help
##done##
#                                                                      #
# Notes -                                                              #
#   Requires Perl.                                                     #
#                                                                      #
# Who  Date      Change                                                #
# -------------------------------------------------------------------- #
# CDS  04/10/14  initial creation                                      #
# CDS  04/10/14  updated to run in different directories               #
# CDS  05/02/24  changed output structure and made more v4 compatible  #
# SKB  05/04/26  added ability to specify usable mc to variation       #
# AJW  05/05/05  added the ability to iterate over a list of compilers #
# AJW  05/10/05  added globalsets and execution logging                #
#______________________________________________________________________#


use File::Basename;    # This is used to split file/path names.
use Cwd;               # This is used to get the current working directory.
use POSIX ":sys_wait_h";
use Threads;

my $specfile = "";            # This is the est specification file.
my $var_name = "";            # This is the name of test variation to run.
my $varnum = 0;               # This is the number of test variation to run.
my $mc = "mc3020";            # This is the name of test variation to run.
my $rox_bin;                  # model compiler bin directory
my %variation_directories = ();     # This is a hash to store the directory name of a variation during this run.
my @default_set           = ();     # This is the default global set.
my $folder_prefix;                  # This is the prefix to the dated directory.
my $child_count           = 0;      # This is the number of children I've spawned.

#---------------------------------------------------------------------------
# Create a build directory in a subdirectory named by date.
# This directory will contain everything run that day including
# looped variations (ALL) that run past midnight.
#---------------------------------------------------------------------------
( $j, $j, $j, $mday, $mon, $year, $j, $j, $j ) = localtime( time );
my $dailydir = sprintf( "%02d%02d%02d", $year % 100, $mon+1, $mday );

sub printhelp { print $help_info; exit; } # This is the end of the sub.

#-------------------------------------------------------------------
# Print the input test information into the build directory.
#-------------------------------------------------------------------
sub put_stuff( $$$$$ );
sub put_stuff( $$$$$ )
{
  my $bd = shift( @_ ); $p = shift( @_ ); my $s = shift( @_ );
  my $d = shift( @_ ); my $t = shift( @_ );
  open ( O, ">>$bd/$d" ) or die "Could not open $bd/$d for appending.\n";
  if ( $s )
  {
    open (I, "<$p/$s") or die "Could not open $p/$s for reading.\n";
    while ( <I> ) { print O; }
    close I;
  }
  else
  {
    print "$d:  $t";
    print O  $t;
  }
  close O;
}

#---------------------------------------------------------------------------
# test_variation
# parameters - string of variation to run
#            - string of the path to the variation
#            - reference to hash with variation attrs
#            - boolean of if the executable should be run or not
#            - reference to the global set to run on
#            - string of the global set name
#            - string of the name of the global set
#            - the default set parameters
#            - compilers suitable for the global set
#            - perform XMI export or not
# returns    - nothing
# This function is responsible for the code gen, compilation, and execution
# of every variation-global set pair.
#---------------------------------------------------------------------------
sub test_variation( $$$$$$$$$$ );
sub test_variation( $$$$$$$$$$ )
{
  my $varname = shift(@_); my $spath = shift(@_);
  my $varattrs = shift(@_);    # This is a reference to hash containing variation attributes.
  my $run_exec = shift(@_);    # This is a flag to see if the resulting executable should be run.
  my @globals = @{shift(@_)};  # This is a reference to the globals to run on this variation.
  my $global_set_name = shift(@_); # This is the compiler the global set was meant for.
  my $global_comp = shift(@_); # This is the name of the global set.
  my @default     =@{shift(@_)};# This is the default set.
  my @code_compilers = @{shift(@_)};# This is the list of code compilers appropriate for the global set.
  my $do_XMI_export = shift(@_); # Do we want to run the build as an XMI export
  print "code compilers = @code_compilers\n";
  my @vars;                # This is variation specific information.
  my @field;               # These are fields from the variations file rows.
  my @cmd_args = "";       # These are arguments to the xtumlmc_build command.
  my $cmd;                 # This is string for shell command.
  my %compilers = ();           # This is a hash of a list of compilers, that has the makefile,
                           # the makefile for that compiler is copied into, and
                           # list of the compiler subdirectories.
  my $log_dir;             # This is where log files should be copied.
  my $var_dir;             # This is the directory the variation is in.
  srand (time() ^ ($$ + ($$ << 15)) ); # Seed pseudo-random number generator.

  # Scan for variation level parameters from the input file.
  seek SF, 0, 0;    # rewind the file
  while ( <SF> )
  {
    @vars = ( @vars, $_ )
      if ( /<variation name="$varname"/ ... /<\/variation>/ ) && /:/ && !/#/;
  }

  # Check for XMI export
  if ( $do_XMI_export ) {
    @cmd_args = ( " -i ", @cmd_args );
  }

  # Apply variation attributes.
  my $ok_to_run = 0;
  while ( my ($key, $value) = each( %$varattrs ) )
  {
    if ( $key =~ /^mc/ )
    {
      # Make sure the attribute specifies a specific model compiler, Make sure
      # the user has chosen to run that model compiler.
      if ( ( $value =~ /3020/ ) && ( $mc =~ /3020/ ) )
      {
        @cmd_args = ( @cmd_args, " -3 " );  # It is really easy to add -l3b here for binary MC.
        $ok_to_run = 1;
      }
      elsif ( ( $value =~ /2020/ ) && ( $mc =~ /2020/ ) )
      {
        @cmd_args = ( @cmd_args, " -2 " );
        $ok_to_run = 1;
      }

    if( (lc( $value ) ne lc( $global_comp )) && ($global_comp !~ /all/i) )
    {
        print "\"$varname\" variation incompatible with global set \"$global_set_name\"\n";
        return;
    }
    }
  }

  if ( $ok_to_run )
  {
    print "Running $mc variation \"$varname\" with global set \"$global_set_name\"\n";
  }
  else
  {
    print "\"$varname\" variation invalid for $mc\n";
    return;
  }

  # Use the name of the variation for the build directory.
  # Append a .number if necessary.

  #check to see if this variation has already been done during this execution, if it has, use that directory
  my $builddir = ""; #directory code compilation takes place in
  my $temp_builddir = "";
  my $have_dir_flag = 0;
  my $var_pathname = $varname;
  for $temp_buildvar( keys %variation_directories )
  {
    if( lc($varname) eq lc($temp_buildvar) ) #it's been done, take the previous parameters
    {
      $have_dir_flag = 1;
      $directories = $variation_directories{$varname};
      $builddir = "$directories/code-$global_set_name";
      $temp_builddir = $directories;
      mkdir $builddir;
  }
  }

  # Try to create the date/varname directory.  After that succeeds, create the code directory,
  # and store it so later code generations can find it.

  # Have_dir_flag is set if we found the directory above.
  # Skip this if the flag is set.
  if( $have_dir_flag == 0 )
  {
    # If the user specified a prefix, append it to the date/varname,
    # else just use date/varname.
    if( defined $folder_prefix )
    {
      $temp_builddir = "$folder_prefix$dailydir/$varname";
  }
    else
  {
      $temp_builddir = "$dailydir/$varname";
  }
  print "$temp_builddir\n";

  # Make the directory. If we fail, increment counter
  # and append that to the end of the name until we succeed.
  if ( ! mkdir $temp_builddir )
    {
      my $counter = 0;
      do
      {
        $counter++;
        if( defined $folder_prefix )
        {
          $temp_builddir = "$folder_prefix$dailydir/$varname" . "." . "$counter";
    }
    else
    {
          $temp_builddir = "$dailydir/$varname" . "." . "$counter";
    }
       } until mkdir $temp_builddir;
  }
    $builddir = "$temp_builddir/code-$global_set_name";
    mkdir $builddir;
    my $the_dirs = $temp_builddir;
    $variation_directories{$varname} = $the_dirs;
  }

  # make the bin directory and split the directory we're code gen'ing
  # in into parts (i.e. dir/var becomes (dir,var).

  my $bindir = "$temp_builddir/bin";
  mkdir $bindir;
  @temp_build_dir_parts = split( '/',$temp_builddir );

  # Loop through the list of parameters, looking for the makes.
  # Parse the filename into type (like MVC, etc) and filename
  # and store for later.

  foreach( @vars,@globals,@default )
  {
    @vars_split = split /:/;

  # Is this a make?
    if( $vars_split[0] =~ /make/ )
    {
      # Yes, split the filename into make.ext (extension).
      # Ext becomes what we regard the type of compiler as.
      @filename = split( /\./,$vars_split[1] );
      $compiler = $vars_split[1]; #compiler makefile
      $compilers_dest = $vars_split[2]; #what the makefile is copied into
      $mkdir_target_dir = "$builddir";
      $target_dir = "$builddir"; #where we copy the makefile
      my @temp_arr = ($compilers_dest,$target_dir,$filename[1],$mkdir_target_dir);
      $compilers{ $compiler } = \@temp_arr;
  }
  }

  # Create log dir.
  $log_dir = "$temp_builddir/log";
  mkdir $log_dir;

  # Deploy the test variation parameters into the build directory.
  # Process variations first, global section second, default section third

  my $previous_file = "janshsi";
  @cmd_args = ( @cmd_args, " -d g" );
  my @domain_names = ();

  my %file_hash = ();

  foreach ( @vars, @globals,@default )
  {
    @field = split /:/;
    my $pers_flag = 0;
    my $filename = "";
    if ( $field[ 0 ] =~ /sql/ )
    {
      if ( $field[ 1 ] =~ /[A-Za-z]/ )
      {
        put_stuff( $builddir, $spath, $field[ 1 ], $field[ 2 ], $field[ 3 ] );
        my @ooa = split /\./, $field[ 2 ];
        @cmd_args = ( @cmd_args, " -o " . $ooa[ 0 ] );
        @cmd_args = ( @cmd_args, " -s " . $field[ 2 ] );
      }
      else
      { # if no sql file name supplied, default to variation name.bak
        put_stuff( $builddir, $spath, $varname . ".bak", $varname . ".bak", "" );
        @cmd_args = ( @cmd_args, " -o " . $varname );
        @cmd_args = ( @cmd_args, " -s " . $varname . ".bak" );
      }
    }
    elsif ( $field[ 0 ] =~ /mark/ )
    {
      if ( $field[ 3 ] =~ /TagModelDebuggingOn/ )
      {
        @cmd_args = ( @cmd_args, " -g " );
      }
    put_stuff( $builddir, $spath, $field[ 1 ], $field[ 2 ], $field[ 3 ] );
    $previous_file = $file_hash{ $field[2] };
        @cmd_args = ( @cmd_args, " -f " . $field[ 2 ] )
           if ( !defined $previous_file || $previous_file != 1);
        $file_hash{ $field[2] } = 1
    }
    elsif ( $field[ 0 ] =~ /c|h|make|link/ )
    {
      put_stuff( $builddir, $spath, $field[ 1 ], $field[ 2 ], $field[ 3 ] );
      $previous_file = $file_hash{ $field[2] };
      @cmd_args = ( @cmd_args, " -f " . $field[ 2 ] )
        if ( !defined $previous_file  || $previous_file != 1);
      $file_hash{ $field[2] } = 1;
    }
  }

  # Run the build.
  my $date = localtime;
  $cmd = "echo Beginning code generation at $date > $log_dir/$varname-$global_set_name-gen.log;";
  if ( -f "$rox_bin/xtumlmc_build.pl" ) {
    print "Running the PERL interpretted version of xtumlmc_build.\n";
    $cmd .= "cd $builddir; $rox_bin/xtumlmc_build.pl @cmd_args";
  } else {
    $cmd .= "cd $builddir; $rox_bin/xtumlmc_build @cmd_args";
  }

  print "Beginning code generation for $varname with $global_set_name\n";

  # Generate code generation log no matter what.
  my $ascend="../";
  my $parts_count = 0;
  foreach( @temp_build_dir_parts )
  {
    $ascend .= "../";
    $parts_count = $parts_count+1;
  }
  $cmd .= " >> $ascend$log_dir/$varname-$global_set_name-gen.log 2>&1";
  open( O, ">$builddir/buildit" ) or die "Could not open $builddir/buildit.\n";
  print O  $cmd;
  close O;
  system $cmd;

  # Record end time.
  $date = localtime;
  $cmd = "echo End code generation at $date >> $log_dir/$varname-$global_set_name-gen.log 2>&1";
  print "Ending code generation for $varname with $global_set_name\n";
  system $cmd;

  # Go back to root dir.
  $ascend = "../";
  for( $i =0;$i < $parts_count-2;$i++ )
  {
    $ascend .= "../";
  }
  $cmd = "cd ../..;";
  system $cmd;

  # Copy the new makefile into the code gen directory, make all_no_gen
  # in it, and log the result, running the executable if needed

  print "doing compilation\n";
  foreach $compiler( keys %compilers )
  {
    my @compilers_opts = @{$compilers{$compiler}}; #get the compiler details
    my $makefile = $compiler;
    my $dest_makefile = $compilers_opts[0];
    $compiler_path = $compilers_opts[1];
    $compiler_type = $compilers_opts[2];

  # Look to see if this makefile is a valid compiler for the global set.
  my $found_it = 0;
  foreach $comps( @code_compilers)
  {
      $found_it = 1 if (lc($comps) eq lc($compiler_type) || lc($comps) eq "all");
  }

  # Nope, skip it.
    next if ($found_it == 0);

  # Copy the makefile.
    print "\nBeginning compilation of $varname and $global_set_name with $compiler_type.\n";
    $system_cmd = "cp $makefile $compiler_path/$dest_makefile;cp $makefile $compiler_path/g/$dest_makefile;rm $compiler_path/g/bin/* > junk 2>&1";
    system $system_cmd;
    #descend into every directory and make all_no_gen
    $root_log_file = "$log_dir/$varname-$global_set_name-$compiler_type.log";
    $ascend = "../../";
    for( $i =0;$i < $parts_count;$i++ )
    {
      $ascend .= "../";
    }
    $log_file = "$ascend$log_dir/$varname-$global_set_name-$compiler_type.log";

    $date = localtime;

    # Do the compilation.
    $system_cmd = "echo Beginning compilation at $date > $root_log_file;";

    if ( "mc3020" eq $mc ) {
      $system_cmd .= "cd $compiler_path/g;make all_no_gen >> $log_file 2>&1;cd $ascend";
    } else {
      $system_cmd .= "cd $compiler_path/g;make comp_link_all >> $log_file 2>&1;cd $ascend";
    }

    system $system_cmd;
    $date = localtime;
    $system_cmd = "echo Ending compilation at $date >> $root_log_file;";
    system $system_cmd;

    # Copy the executable to the bin directory.
    my $executable_dest = "$bindir/$varname-$global_set_name-$compiler_type.exe";
    my $exec_without_exe = "$varname-$global_set_name-$compiler_type";

    my $gened_exe;
    if( $mc eq "mc3020" ) {
      $gened_exe = "rox.exe";
    } else {
      $gened_exe = "ptc.exe";
    }
    $cmd = "cp $compiler_path/g/bin/$gened_exe $executable_dest > junk 2>&1;rm $compiler_path/g/bin/$gened_exe > junk 2>&1;rm junk";
    system $cmd;

    print "\nFinished compilation of $varname and $global_set_name with $compiler_type.\n";

    # Execute the resulting binary, logging the results.
    my $executable = "$compiler_path/g/bin/rox.exe";
    my $execution_log = "$log_dir/$varname-$global_set_name-$compiler_type-exec.log";
    if( $run_exec == 1 )
    {
      print "\nRunning executable $exec_without_exe.exe\n";

      # Fork off a child process so if Very Bad Things happen, it won't ruin the whole test.
      my $pid = fork;
     if( $pid == 0 )
     {
        # Evaluate the child with an eval, so we can kill it if it stalls.
        eval
        {
          # Set up the signal handler
          local $SIG{ALRM} = sub
          {
            my $ppid = getppid;
            kill 'USR1',$ppid;
            # Query ps for the process.
            my @procs = qx/ps/;
            my @lines = grep{ /$exec_without_exe/i } @procs;
            exit if !(@lines); # The executable is done already, no need to kill it

            # Split the line with the executable into parts, grab the pid.
            ($pid) = split(' ',$lines[0]);
            # Kill it and log that something went wrong.
            print "\n$exec_without_exe.exe timed out.\n";
            $system_error = "echo Failure: Process timed out >> $execution_log;";
            $system_error .= "echo Ending execution with a timeout at >> $execution_log;";
            $system_error .= "date >> $execution_log;";
            $system_error .= "kill $pid;";
            $system_error .= "cp nvs.fil ../../../../$log_dir/$exec_without_exe-nvs.fil > junk 2>&1;rm junk;";
            system($system_error);
            # Get the parent ID, tell it we're done.
            exit;
          };
          alarm(5*60);
          # This is the child,execute the command.
          $date = localtime;
          $system_cmd = "echo Beginning execution at $date > $execution_log;";
          $system_cmd .= "cd $bindir;";
          $system_cmd .= "mkdir exec-$exec_without_exe;";
          $system_cmd .= "cp $exec_without_exe.exe exec-$exec_without_exe > junk 2>&1;rm junk;";
          $system_cmd .= "cd exec-$exec_without_exe;";
          $system_cmd .= "nice $varname-$global_set_name-$compiler_type.exe >> ../../../../$execution_log 2>&1;";
          $system_cmd .= "echo Ending execution at >> ../../../../$execution_log;";
          $system_cmd .= "date >> ../../../../$execution_log;";
          $system_cmd .= "cp nvs.fil ../../../../$log_dir/$exec_without_exe-nvs.fil > junk 2>&1;rm junk;";
          system($system_cmd);
          my $ppid = getppid;
          kill 'USR1',$ppid;
          print "\n$exec_without_exe.exe finished.\n";
          alarm 0;
          exit;
        };
      }
      # Record we spawned the thread, so we can wait for it later.
      lock $child_count;
      $child_count++ if($pid > 0);
    }


 }
}

#---------------------------------------------------------------------------
# get_global_params
# parameters - string of the global set to get the parameters for
# returns    - an array of the global set parameters
#
# This function gets the parameters of the passed-in global set, and
# returns them in an array.
#---------------------------------------------------------------------------
sub get_global_params( $ );
sub get_global_params( $ )
{
  # Enumerate here, also, returning an array of arrays, rather than just an array.
  my $globalsetname = shift( @_ );
  # Scan for global and variation level parameters from the input file.
  my @globals;
  seek GF, 0, 0;    # rewind the file
  while ( <GF> )
  {
    @globals = ( @globals, $_ )
      if ( /<globalset name="$globalsetname"/ ... /<\/globalset>/ ) && /:/ && !/#/ ;
  }
  return @globals;
}

#---------------------------------------------------------------------------
# get_global_attrs
# parameters - string of the global set to get attributes for
# returns    - an array of the global set parameters
#
# This function gets the attributes of the passed-in global set, and
# returns them in an array.
#---------------------------------------------------------------------------
sub get_global_attrs( $ );
sub get_global_attrs( $ )
{
  my $found_global = 0;
  my $vname = shift ( @_ );
  my %global_attrs;
  while ( <GF> )
  {
    if ( /<globalset name="$vname"/ )
    {
      s/<globalset//; s/>.*$//; chop;

      my @pairs = split /" /;
      foreach ( @pairs )
      {
        s/^\s//; s/"//g; m/=/;
        $global_attrs{$`} = $';
      }
      $found_global = 1;
      last;
    }
  }
  die "$vname not a valid global section in $specfile.\n" if(!$found_global);
  return %global_attrs;
}

#---------------------------------------------------------------------------
# get_global_attrs
# parameters - string of the global set to get attributes for
# returns    - an array of the global set parameters
#
# This function gets the attributes of the passed-in global set, and
# returns them in an array.
#---------------------------------------------------------------------------
sub get_variation_attrs( $ );
sub get_variation_attrs( $ )
{
  my $found_var = 0;
  my $vname = shift ( @_ );
  my %rec_var_attrs;
  while ( <SF> )
  {
    if ( /<variation name="$vname"/ )
    {
      s/<variation//; s/>.*$//; chop;

      my @pairs = split /" /;
      foreach ( @pairs )
      {
        s/^\s//; s/"//g; m/=/;
        $rec_var_attrs{$`} = $';
     }
   $found_var = 1;
     last;
    }
  }
  die "$vname not a valid variation in $specfile.\n" if(!$found_var);
  return %rec_var_attrs;
}

#----------------------------------------------------------------------
# call_variations
# parameters - string of the variation name to call
#            - array of global set attributes
#            - array of default set attributes
#            - string of the model compilers for the global set
#            - string of this global set
#            - boolean on whether to execute the executable
#            - array of the C code compilers for the global set
#            - do XMI export or not
# returns    - nothing
# This function is a glue to call test_variations with the
# passed-in global set, default set, and variation.
#---------------------------------------------------------------------

sub call_variations( $$$$$$$$ );
sub call_variations( $$$$$$$$ )
{
  my $var_name = shift( @_ );
  my @global_set = @{shift( @_ )};
  my @defaults = @{shift( @_ )};
  my $global_set_compiler = shift( @_ );
  my $global_set_name = shift( @_ );
  my $execute_this = shift( @_ );
  my @code_compilers = @{shift( @_ )};
  my $do_XMI_export = shift( @_ );
  my ( $specfilename, $specfilepath ) = fileparse( $specfile );
  open( SF, "<$specfile" ) or die "Could not open $specfile for input.\n";
  if( $var_name =~ /ALL/i )
  {
    my @variations;
    #find all variation names
    while( <SF> )
    {
      if( /<variation name="/ )
      {
        my @a = split /"/;
        @variations = ( @variations, $a[ 1 ] );
      }
    }

    # Call test variations on each variation.
    foreach my $v( @variations )
    {
      seek SF, 0, 0;        # Rewind the file.
      my %var_attrs = get_variation_attrs( $v );
      test_variation( $v, $specfilepath, \%var_attrs,$execute_this,\@global_set,$global_set_compiler,$global_set_name,\@defaults,\@code_compilers,$do_XMI_export );
    }
  }
  else
  {
    # User only wants one specific variation, call everything on this one.
    my %the_var_attrs = get_variation_attrs( $var_name );
    test_variation( $var_name, $specfilepath, \%the_var_attrs,$execute_this,\@global_set,$global_set_compiler,$global_set_name,\@defaults,\@code_compilers,$do_XMI_export );
  }
  close SF;
}

#----------------------------------------------------------------------------
# This is Clay's awsome command line argument interpreter.  Run this to
# load all options in a hash called "%comnd_opts".  The hash key values are
# the command line switches, for example "-path" and the matching value
# of the hash is the option that follows the switch.  A switch is
# identified as a sting that starts with a '-' or a '/' any other
# arguments are considered an option for the preceding switch.
#----------------------------------------------------------------------------
my %comnd_opts;
my $global_name = "default";
for ( my $i = 0; $i < @ARGV; $i++ ) {
  $ARGV[$i] =~ s/^-// and $comnd_opts{ $ARGV[$i] }= "";
  @ARGV >= ($i+2) and $ARGV[$i+1] !~ /^-/ and ($comnd_opts{ $ARGV[$i] } = $ARGV[$i + 1], ++$i);
}

my $k = 0; my $execute_this = 0;
my $nowait = 0;
my $do_XMI_export = 0;
foreach $k ( sort keys %comnd_opts ) {
  $k =~ /^(h|help)$/i and &printhelp;
  $k =~ /^(l|list)$/i and &printhelp;
  $k =~ /^(n|number)$/i and $varnum = $comnd_opts{$k};
  $k =~ /^(s|spec)$/i and $specfile = $comnd_opts{$k};
  $k =~ /^(v|name)$/i and $var_name = $comnd_opts{$k};
  $k =~ /^(m|mc)$/i and $mc = $comnd_opts{$k};
  $k =~ /^(e|exec)$/i and $execute_this = 1;
  $k =~ /^(g|global)$/i and $global_name = $comnd_opts{$k};
  $k =~ /^(pd)$/i and $folder_prefix = $comnd_opts{$k};
  $k =~ /^(nw|nowait)$/i and $nowait = 1;
  $k =~ /^(i)$/i and $do_XMI_export = 1;
}

# Call the help function if no options are specified.
&printhelp if( !keys( %comnd_opts ) );

# Fix the prefix if specified.
if( defined $folder_prefix )
{
  $folder_prefix .="/";
}

# Check to see that the prefix actually exists.
if( defined $folder_prefix && !(-e $folder_prefix) )
{
  print "Specified folder prefix does not exist\n";
  exit;
}

# Append the prefix to the date.
if( defined $folder_prefix )
{
  mkdir "$folder_prefix$dailydir";
}
else
{
  mkdir "$dailydir";
}

#---------------------------------------------------------------------------
# Set up path to the model compiler bin directory.
#---------------------------------------------------------------------------
$rox_bin = ( ! exists $ENV{'ROX_MC_BIN_DIR'} )
  ? "$ENV{'XTUMLMC_HOME'}/$mc/bin"
  : "$ENV{'ROX_MC_BIN_DIR'}";

# Prepend the model compiler bin directory to the PATH.
# This will give the build visibility to our utilties.
$ENV{'PATH'} = ( $ENV{'PATH'} =~ /;/ )
  ? "${rox_bin};$ENV{'PATH'}"
  : "/cygdrive/c/mgc/BridgePoint/eclipse_extensions/BridgePoint/eclipse/plugins/com.mentor.nucleus.bp.mc.${mc}_4.0.0/${mc}/bin:${rox_bin}:$ENV{'PATH'}";

# Read in the global default set first.
open( GF, "<$specfile" ) or die "Could not open $specfile. Please specify a valid specification file.\n";

# Get the default set.
@default_set = get_global_params("default");
seek GF,0,0;

# Install a signal handler to catch dead children and decrement the number of children we have.
$SIG{CHLD} = 'IGNORE';
$SIG{SEGV} = {};
$SIG{USR1} = sub { lock $child_count; $child_count--;};

my ( $specfilename, $specfilepath ) = fileparse( $specfile );

# Call call_variations with every global set the user requests.
if( $global_name =~ /ALL/i )
{
  # User wants to execute on all global sets.
  my @globalsets;
  # Find all global set names.
  while( <GF> )
  {
    if( /<globalset name="/ )
    {
      my @a = split /"/;
      @globalsets= ( @globalsets, $a[ 1 ] );
    }
  }
  my @defaults = @default_set;
  foreach my $g( @globalsets )
  {
    # Get the parameters of the global set and pass everything to call_variations.
    next if( $g =~ /default/ ); #skip the default section
    seek GF, 0, 0;        # Rewind the file.
    my %this_global_attrs = get_global_attrs( $g );
    my $this_global_name = $this_global_attrs{ 'name' };
    my $this_global_compiler = $this_global_attrs{ 'mc' };
    my $this_code_compilers = $this_global_attrs{ 'compiler' };
    my @compilers = split /,/,$this_code_compilers;
    my @this_global_set = get_global_params( $this_global_name );

    # Call this global set only if the model compiler on the global set matches whatwas passed in.
    if( lc( $this_global_compiler ) eq lc( $mc ) || $mc =~ /ALL/i )
    {
      call_variations($var_name,\@this_global_set,\@defaults,$this_global_name,$this_global_compiler,$execute_this,\@compilers,$do_XMI_export);
    }
    else
    {
      print "Specified model compiler invalid for $this_global_name\n";
    }
  }
}
else
{
  # Get the parameters of the global set and pass everything to call_variations.
  my %this_global_attrs = get_global_attrs( $global_name );
  my $this_global_name = $this_global_attrs{ 'name' };
  my $this_global_compiler = $this_global_attrs{ 'mc' };
  my @this_global_set = get_global_params( $this_global_name );
  my $this_code_compilers = $this_global_attrs{ 'compiler' };
  my @compilers = split /,/,$this_code_compilers;
  @this_global_set = (@this_global_set,"test");

  my @defaults = @default_set;
  if( $global_name =~ /default/i )
  { #if the user requested the global set, nullify what we pass in so it just uses the default once
    @this_global_set = ();
  }

  # Call this global set only if the model compiler on the global set matches whatwas passed in.
  if( (lc($this_global_compiler) eq $mc ) || $mc =~ /ALL/i || $this_global_compiler =~ /all/i )
  {
    call_variations($var_name,\@this_global_set,\@defaults,$this_global_name,$this_global_compiler,$execute_this,\@compilers,$do_XMI_export);
  }
  else
  {
    print "Specified model compiler invalid for specified global set\n";
    exit;
  }
}

# Wait for spawned child threads to exit.
print "Waiting for $child_count execution logs to finish\n";
$prev_count = $child_count;
while( $child_count > 0 && !$nowait)
{
  if( $prev_count != $child_count )
  {
    lock $child_count;
    print "Waiting for $child_count execution logs to finish.\n"  if( $child_count > 0 );
    $prev_count = $child_count;
  }
  sleep;
}

# Sleep, so that the exiting thread has a chance to print it's lines before we exit.
sleep 5;

print "All execution logs are finished.\n";

# Reap dead children.
while( waitpid(-1,WNOHANG) > 0 )
{
}



#---------------------------------------------------------------------------
# Clean up, clean up, everybody everywhere!
#---------------------------------------------------------------------------
$cmd = "date";
system $cmd;
close GF;
